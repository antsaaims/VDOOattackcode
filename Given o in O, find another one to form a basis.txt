
/*------------------
We know that once a first vector in O is found; 
we have P(o’) = 0 and P’(o,o’)= p(o+o’) -p(o’)-p(o)=0. 
We are going to do this until we find all the basis vectors of O
I added the contraints manually so that o and o' are 
linearly independant.
I forced o' to have 0 on an entry where o is nonzero
I also added the contraints one by one
*/


printf "*************************************************** \n";
printf "***        Attacking Vdoo Signature Scheme      *** \n";
printf "*** Getting over vectors in o2 to complete the basis *** \n";

printf "*************************************************** \n \n";


q:=4; // Field Size
vdooparameters := [3,4,2,2]; //Write your VDOO parameter here


m:= vdooparameters[2] + vdooparameters[3] +vdooparameters[4] ;
n:= vdooparameters[1] + m;
o2 :=vdooparameters[4];
//GF :=GaloisField(q);
GF<w>:=GaloisField(q);
k := n - o2 + 1;
r := o2;
s := r*(n-r);
vars := [ Sprintf("z%o", j) : j in [1..s] ] cat  [ Sprintf("a%o", i) : i in [1..n] ] ;
//vars;

A:= PolynomialRing(GF, #vars, "lex");

AssignNames(~A, vars);
X := [A.i: i in [s+1..s+k]];
Xfull := [A.i: i in [s+1..s+n]]; //The full vector, used in o'
P<[y]> := PolynomialRing(A,n);
Pol<[x]>:=PolynomialRing(P,n);

// Change this to your public key polynomial

Pk:=  [
w^2*x[1]^2 + w*x[1]*x[3] + x[1]*x[4] + x[1]*x[6] + w*x[1]*x[9] + w*x[1]*x[10] +
w*x[1]*x[11] + w*x[2]^2 + x[2]*x[3] + w*x[2]*x[5] + w*x[2]*x[6] + x[2]*x[7] +
w*x[2]*x[8] + w*x[2]*x[10] + w^2*x[3]^2 + w^2*x[3]*x[5] + w^2*x[3]*x[6] +
w*x[3]*x[7] + w*x[3]*x[8] + w*x[3]*x[10] + w*x[4]^2 + x[4]*x[5] + w^2*x[4]*x[7]
+ w*x[4]*x[8] + x[4]*x[9] + w*x[4]*x[10] + w*x[4]*x[11] + w^2*x[5]^2 +
w*x[5]*x[7] + x[5]*x[8] + w^2*x[5]*x[9] + x[5]*x[11] + x[6]*x[9] +
w^2*x[6]*x[10] + w^2*x[6]*x[11] + w^2*x[7]^2 + x[7]*x[8] + w*x[7]*x[9] +
w^2*x[7]*x[11] + x[8]^2 + x[8]*x[9] + x[8]*x[10] + w^2*x[8]*x[11] + w*x[9]*x[11]
+ w^2*x[10]^2 + w^2*x[10]*x[11] + x[11]^2,
x[1]^2 + w*x[1]*x[2] + w^2*x[1]*x[3] + x[1]*x[4] + w^2*x[1]*x[5] + w^2*x[1]*x[6]
+ w*x[1]*x[8] + w*x[1]*x[9] + w^2*x[1]*x[10] + w^2*x[2]*x[3] + x[2]*x[4] +
x[2]*x[6] + x[2]*x[7] + w^2*x[2]*x[9] + w^2*x[2]*x[10] + w^2*x[2]*x[11] +
w*x[3]^2 + w*x[3]*x[4] + x[3]*x[5] + x[3]*x[6] + w^2*x[3]*x[7] + w^2*x[3]*x[8] +
w^2*x[3]*x[9] + x[4]^2 + w*x[4]*x[5] + w^2*x[4]*x[6] + w*x[4]*x[7] + w*x[4]*x[8]
+ w*x[4]*x[9] + w^2*x[4]*x[10] + w*x[4]*x[11] + w^2*x[5]*x[7] + x[5]*x[8] +
w^2*x[5]*x[11] + w^2*x[6]^2 + x[6]*x[7] + w*x[6]*x[8] + x[6]*x[9] + x[6]*x[10] +
w^2*x[6]*x[11] + w^2*x[7]^2 + x[7]*x[8] + w^2*x[7]*x[11] + w^2*x[8]^2 +
x[8]*x[9] + w*x[8]*x[10] + w^2*x[8]*x[11] + w^2*x[9]*x[11] + w*x[10]^2 +
x[10]*x[11] + w*x[11]^2,
w*x[1]^2 + w*x[1]*x[4] + w*x[1]*x[5] + w*x[1]*x[6] + x[1]*x[7] + w^2*x[1]*x[9] +
x[1]*x[10] + x[1]*x[11] + w*x[2]*x[3] + w^2*x[2]*x[4] + w^2*x[2]*x[5] +
x[2]*x[6] + w*x[2]*x[7] + w*x[2]*x[8] + w^2*x[2]*x[9] + w*x[2]*x[10] +
w^2*x[2]*x[11] + w^2*x[3]*x[4] + w^2*x[3]*x[5] + x[3]*x[8] + w^2*x[3]*x[9] +
w^2*x[3]*x[10] + w^2*x[3]*x[11] + w*x[4]^2 + x[4]*x[5] + w^2*x[4]*x[6] +
w^2*x[4]*x[7] + w^2*x[4]*x[8] + x[4]*x[10] + w^2*x[4]*x[11] + w*x[5]^2 +
w*x[5]*x[6] + w*x[5]*x[7] + x[5]*x[9] + w*x[5]*x[10] + w*x[5]*x[11] + w^2*x[6]^2
+ w^2*x[6]*x[7] + w*x[6]*x[9] + w^2*x[6]*x[11] + w*x[7]^2 + w^2*x[7]*x[8] +
x[7]*x[10] + w*x[7]*x[11] + x[8]^2 + x[8]*x[11] + x[9]^2 + x[9]*x[10] +
w*x[9]*x[11] + x[10]^2 + w^2*x[11]^2,
w^2*x[1]^2 + w*x[1]*x[2] + w^2*x[1]*x[3] + w^2*x[1]*x[4] + w^2*x[1]*x[5] +
w^2*x[1]*x[6] + w*x[1]*x[9] + x[2]^2 + x[2]*x[3] + x[2]*x[4] + w*x[2]*x[5] +
w^2*x[2]*x[6] + w*x[2]*x[7] + w^2*x[2]*x[8] + w^2*x[2]*x[10] + x[2]*x[11] +
w*x[3]^2 + w^2*x[3]*x[6] + w^2*x[3]*x[7] + w^2*x[3]*x[8] + w^2*x[3]*x[9] +
w^2*x[3]*x[10] + w^2*x[3]*x[11] + x[4]^2 + w^2*x[4]*x[5] + w^2*x[4]*x[7] +
x[4]*x[8] + w*x[4]*x[11] + w^2*x[5]^2 + x[5]*x[6] + w*x[5]*x[7] + w*x[5]*x[10] +
w*x[5]*x[11] + w*x[6]^2 + x[6]*x[7] + w^2*x[6]*x[9] + w^2*x[6]*x[10] +
x[6]*x[11] + w*x[7]^2 + x[7]*x[9] + x[7]*x[10] + w^2*x[7]*x[11] + w*x[8]*x[9] +
w^2*x[8]*x[10] + w*x[8]*x[11] + w^2*x[9]^2 + x[10]^2 + w^2*x[10]*x[11],
x[1]*x[2] + w*x[1]*x[3] + w*x[1]*x[4] + x[1]*x[5] + x[1]*x[6] + w*x[1]*x[8] +
x[1]*x[9] + w^2*x[1]*x[11] + w^2*x[2]^2 + w*x[2]*x[3] + w*x[2]*x[4] + x[2]*x[7]
+ w*x[2]*x[8] + w^2*x[2]*x[9] + x[2]*x[10] + w*x[2]*x[11] + w*x[3]^2 +
w^2*x[3]*x[5] + w*x[3]*x[6] + w^2*x[3]*x[7] + w*x[3]*x[8] + x[3]*x[10] +
w^2*x[3]*x[11] + x[4]^2 + w*x[4]*x[5] + w^2*x[4]*x[6] + w*x[4]*x[7] +
w^2*x[4]*x[8] + w*x[4]*x[9] + w^2*x[4]*x[10] + w*x[4]*x[11] + x[5]^2 +
w*x[5]*x[6] + w*x[5]*x[8] + w*x[5]*x[9] + w^2*x[5]*x[10] + w^2*x[5]*x[11] +
w^2*x[6]^2 + w^2*x[6]*x[7] + w*x[6]*x[8] + w^2*x[6]*x[9] + x[6]*x[10] +
w*x[6]*x[11] + x[7]^2 + w^2*x[7]*x[9] + x[7]*x[11] + w^2*x[8]^2 + w^2*x[8]*x[9]
+ x[8]*x[10] + x[9]^2 + w^2*x[9]*x[10] + x[9]*x[11] + w*x[10]^2,
x[1]^2 + w*x[1]*x[2] + x[1]*x[3] + x[1]*x[4] + x[1]*x[5] + x[1]*x[7] +
w*x[1]*x[8] + w^2*x[1]*x[9] + w*x[1]*x[10] + w*x[1]*x[11] + w^2*x[2]^2 +
x[2]*x[3] + w*x[2]*x[4] + w*x[2]*x[6] + x[2]*x[7] + x[2]*x[8] + w^2*x[2]*x[10] +
x[2]*x[11] + x[3]^2 + x[3]*x[9] + w^2*x[4]^2 + w*x[4]*x[7] + w^2*x[4]*x[8] +
w^2*x[4]*x[9] + x[4]*x[10] + w^2*x[4]*x[11] + w*x[5]^2 + w*x[5]*x[6] +
w*x[5]*x[8] + w^2*x[5]*x[10] + x[5]*x[11] + x[6]*x[7] + w*x[6]*x[8] +
w^2*x[6]*x[9] + w*x[6]*x[10] + w^2*x[7]^2 + w*x[7]*x[8] + x[7]*x[10] +
x[7]*x[11] + w^2*x[8]*x[9] + w^2*x[8]*x[10] + w^2*x[9]^2 + w^2*x[9]*x[10] +
w*x[9]*x[11] + x[10]^2 + w*x[10]*x[11],
w*x[1]^2 + w^2*x[1]*x[2] + w*x[1]*x[4] + w^2*x[1]*x[6] + x[1]*x[7] +
w^2*x[1]*x[8] + x[1]*x[9] + w*x[1]*x[10] + x[1]*x[11] + w^2*x[2]*x[4] +
x[2]*x[6] + w*x[2]*x[9] + w^2*x[2]*x[10] + x[2]*x[11] + x[3]^2 + x[3]*x[5] +
w^2*x[3]*x[6] + w*x[3]*x[7] + w*x[3]*x[8] + w*x[3]*x[9] + x[3]*x[10] +
x[3]*x[11] + x[4]^2 + w^2*x[4]*x[5] + w^2*x[4]*x[6] + w^2*x[4]*x[7] + x[4]*x[8]
+ w^2*x[4]*x[10] + x[4]*x[11] + w^2*x[5]^2 + x[5]*x[7] + x[5]*x[9] + x[5]*x[10]
+ x[5]*x[11] + w^2*x[6]^2 + w^2*x[6]*x[7] + w^2*x[6]*x[8] + x[6]*x[9] +
x[6]*x[10] + x[6]*x[11] + x[7]^2 + x[7]*x[8] + x[7]*x[9] + w^2*x[7]*x[10] +
x[7]*x[11] + x[8]*x[9] + w^2*x[8]*x[10] + x[8]*x[11] + x[9]^2 + w*x[9]*x[10] +
x[9]*x[11] + w*x[10]^2 + x[10]*x[11] + w*x[11]^2,
w^2*x[1]*x[3] + w^2*x[1]*x[4] + x[1]*x[5] + w*x[1]*x[7] + x[1]*x[8] +
w*x[1]*x[10] + w*x[1]*x[11] + w*x[2]^2 + w*x[2]*x[3] + w^2*x[2]*x[5] +
w^2*x[2]*x[7] + w^2*x[2]*x[8] + w^2*x[2]*x[9] + w*x[2]*x[11] + x[3]^2 +
x[3]*x[4] + w*x[3]*x[5] + x[3]*x[6] + x[3]*x[7] + w*x[3]*x[8] + w^2*x[3]*x[10] +
x[3]*x[11] + x[4]^2 + w*x[4]*x[5] + w^2*x[4]*x[6] + x[4]*x[7] + x[4]*x[8] +
w^2*x[4]*x[10] + w*x[4]*x[11] + x[5]^2 + w^2*x[5]*x[6] + x[5]*x[7] + x[5]*x[8] +
w^2*x[5]*x[9] + w^2*x[5]*x[10] + x[5]*x[11] + w*x[6]^2 + w^2*x[6]*x[7] +
x[6]*x[8] + x[6]*x[9] + w*x[7]^2 + w^2*x[7]*x[8] + w^2*x[7]*x[9] + x[7]*x[10] +
x[8]^2 + w^2*x[8]*x[9] + x[8]*x[10] + x[8]*x[11] + x[9]^2 + w^2*x[9]*x[10] +
x[9]*x[11] + w^2*x[10]*x[11] + x[11]^2
] ;

// Public key ends here, don't touch anything below

Hashspace:=VectorSpace(GF,m);
Signspace:= VectorSpace(GF,n);

// creating the basis vectors

basis_vectors := [ Signspace!([ i eq j select 1 else 0 : j in [1..n] ]) 
    : i in [1..n]
];
//basis_vectors;

yvar :=   Vector(([P.i: i in [1..n]]));
 
Pprimelist:= [Vector(Evaluate( Pk, Eltseq(yvar + basis_vectors [i] ))) 
             - Vector(Evaluate( Pk, Eltseq( basis_vectors [i] )))
             -Vector(Evaluate( Pk, Eltseq(yvar  ))): i in [1..n]];      
//Qdeformed := [([ Eltseq(Evaluate( Pprimelist[i], Eltseq(basis_vectors [j])) ): i in [1..n]]):j in [1..n]];

Qdeformed := [Matrix(A,([ Eltseq(Evaluate( Pprimelist[i], Eltseq(basis_vectors [j])) ): i in [1..n]])):j in [1..n]];


//Find Q so that we use a linear system of p'(o,o') 
//instead of a quadratic one

//Transpose all the matrices in Qdeformed once
Qsdeftransposed := [Transpose(Qdeformed[i]): i in [1..n]];
//printf "Qsdeftransposed";
//Qsdeftransposed ;
//#Qsdeftransposed ;
Qsym :=[Transpose(Matrix([(Qsdeftransposed[i][j]): i in [1..n]])): j in [1..m] ]; 
//Qsym ;


foundvecs:= [Matrix(A,[[w,0,0,1,w,1,0,w,1,1,0]])];//The vectors we already have, 
//written as 1 by n matrix, you can run this over and over again 
//and just copy and paste the vectors you found

newvec:=  Matrix(A,[[Xfull [i]: i in [1..n]]]);
//Eltseq(newvec);

PolyList  := Evaluate(Pk, Eltseq(newvec));// P(o')=0
printf "Number of equations";
#PolyList;
for i in [1..#foundvecs] do
    for j in [1..m] do
    PolyList := PolyList cat Eltseq(foundvecs[i]*Qsym[j]*Transpose(newvec) ); 
    end for;
end for;
//PolyList;
newvec[1];
//add any additional affine constraints manually
// Start by setting some entries to 0 or 1 and see if it is consistent
//Listcontraints := [ newvec[1][1] -1, newvec[1][2] ,newvec[1][6]-w^2 ,  newvec[1][10]-w^2 ,  newvec[1][9]-w^2 , newvec[1][7] ,newvec[1][5]-1 ,newvec[1][8] +1, newvec[1][11]  ];
Listcontraints := [ newvec[1][1],newvec[1][2] -1, newvec[1][11],newvec[1][9],newvec[1][10]-1,newvec[1][7]-w^2,newvec[1][8]-w^2];

PolyList:=  PolyList cat Listcontraints;
I := ideal< A| PolyList >;
G := GroebnerBasis(I);
printf "Here is G\n";
print(G);
